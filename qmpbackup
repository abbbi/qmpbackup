#!/usr/bin/env python3
"""
 qmpbackup: Full an incremental backup using Qemus
 dirty bitmap feature

 Copyright (C) 2022  Michael Ablassmeier

 Authors:
  Michael Ablassmeier <abi@grinser.de>

 This work is licensed under the terms of the GNU GPL, version 3.  See
 the LICENSE file in the top-level directory.
"""
import os
import sys
import asyncio
import signal
import argparse
from datetime import datetime
from qemu.qmp import QMPClient

from libqmpbackup.qmpcommon import QmpCommon
from libqmpbackup.lib import QmpBackup
from libqmpbackup import vm
from libqmpbackup import version

SIGNAL_CATCHED = False


async def stop_jobs(blockdev, log, qmp, signal):
    """Catch signal: for some reason, cancelling the
    running block jobs with block-job-cancel issues
    a regular BLOCK_JOB_COMPLETED in the event loop,
    for some reason. Thus exit with different exit code
    by using global variable :/
    """
    global SIGNAL_CATCHED
    log.error("Caught signal: %s", signal)
    log.error("Stopping backup jobs")
    SIGNAL_CATCHED = True
    jobs = await qmp.execute("query-block-jobs")
    if not jobs:
        log.info("No running jobs found")
    for job in jobs:
        for dev in blockdev:
            if job["device"] == dev.node and job["type"] == "backup":
                await qmp.execute(
                    "block-job-cancel", arguments={"device": dev.node, "force": True}
                )


async def main():
    """qmpbackup"""
    parser = argparse.ArgumentParser(
        description="Backup QEMU virtual machines",
        epilog=(
            "Examples:\n"
            "   # full backup with all attached disks:\n"
            "\t%(prog)s --socket /tmp/sock backup --level full --target /backup/\n"
            "   # incremental backup with all attached disks:\n"
            "\t%(prog)s --socket /tmp/sock backup --level inc --target /backup/\n"
            "   # show attached block devices:\n"
            "\t%(prog)s --socket /tmp/socket info --show blockdev\n"
            "   # full backup but exclude disk:\n"
            "\t%(prog)s --socket /tmp/sock backup --level full --exclude ide0-hd0"
            " --target /backup/\n"
        ),
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "--socket", dest="socket", help="qmp socket to connect", required=1
    )
    parser.add_argument(
        "--agent-socket",
        dest="agentsocket",
        help="socket to use for communication with qemu agent",
        required=0,
    )
    parser.add_argument(
        "--debug",
        dest="debug",
        help="more verbose output",
        action="store_true",
        required=0,
    )
    parser.add_argument(
        "--logfile",
        dest="logfile",
        help="log output to specified logfile",
        required=0,
    )
    subparsers = parser.add_subparsers(help="sub-command help")
    parser_backup = subparsers.add_parser("backup", help="backup")
    parser_backup.set_defaults(which="backup")
    parser_backup.add_argument(
        "--level",
        choices=["full", "inc", "auto"],
        type=str,
        help="backup level",
        required=True,
    )
    parser_backup.add_argument(
        "--exclude",
        type=str,
        default=None,
        help="exclude block device from backup",
        required=False,
    )
    parser_backup.add_argument(
        "--include",
        type=str,
        default=None,
        help="backup only specific block device",
        required=False,
    )
    parser_backup.add_argument(
        "--monthly",
        action="store_true",
        help="monthly backup directories (in format YYYY-MM). If combined with backup level 'auto' this will create monthly backup chains.",
        required=False,
    )
    parser_backup.add_argument(
        "--quisce",
        action="store_true",
        help="Use Qemu Agent to quisce filesystem",
        required=False,
    )
    parser_backup.add_argument(
        "--target", type=str, help="backup target directory", required=True
    )
    parser_cleanup = subparsers.add_parser("cleanup", help="cleanup functions")
    parser_cleanup.set_defaults(which="cleanup")
    parser_cleanup.add_argument(
        "--remove-bitmap",
        action="store_true",
        help="remove existent bitmaps for all devices",
        required=True,
    )
    parser_info = subparsers.add_parser("info", help="print info about VM")
    parser_info.set_defaults(which="info")
    parser_info.add_argument(
        "--show",
        choices=["blockdev", "bitmaps"],
        type=str,
        help="show block device information",
        required=True,
    )
    argv = parser.parse_args()
    try:
        action = argv.which
    except AttributeError:
        parser.print_help()
        sys.exit(1)

    common = QmpBackup(argv.debug)
    log = common.setup_log(argv.logfile)
    log.info("Version: %s Arguments: %s", version.VERSION, " ".join(sys.argv))

    if action == "backup" and argv.exclude and argv.include:
        log.error("Specify either included or excluded devices")
        sys.exit(1)

    new_monthly = False
    qmp = QMPClient()
    try:
        await qmp.connect(argv.socket)
    except Exception as errmsg:
        log.fatal("Can't connect QMP socket [%s]: %s", argv.socket, errmsg)
        sys.exit(1)

    status = await qmp.execute("query-status")
    if status["running"] is False and not status["status"] in ("prelaunch", "paused"):
        log.fatal("VM not ready for backup, state: [%s]", status)
        sys.exit(1)

    log.info("VM is in state: [%s]", status["status"])

    qemu_client = QmpCommon(qmp)

    hv_version = qmp._greeting._raw["QMP"]
    qemu = hv_version["version"]["qemu"]
    log.info(
        "Qemu version: [%s.%s.%s] [%s]",
        qemu["major"],
        qemu["micro"],
        qemu["minor"],
        hv_version["version"]["package"],
    )

    excluded_disks = None
    if action == "backup":
        excluded_disks = None
        if argv.exclude is not None:
            excluded_disks = argv.exclude.split(",")
            log.debug("Excluded disks: %s", excluded_disks)

    included_disks = None
    if action == "backup":
        included_disks = None
        if argv.include is not None:
            included_disks = argv.include.split(",")
            log.debug("Backing up only specified disks: %s", included_disks)

    blockdev = vm.get_block_devices(
        await qemu_client.do_query_block(), excluded_disks, included_disks
    )

    loop = asyncio.get_event_loop()
    for signame in ("SIGINT", "SIGTERM"):
        loop.add_signal_handler(
            getattr(signal, signame),
            lambda signame=signame: asyncio.create_task(
                stop_jobs(blockdev, log, qmp, signame)
            ),
        )

    if blockdev is None:
        log.error("VM does not have any devices suitable for backup")
        sys.exit(1)

    if action == "info":
        if argv.show == "blockdev":
            log.info("Attached block devices:")
            log.info("%s", common.json_pp(blockdev))
        if argv.show == "bitmaps":
            for dev in blockdev:
                if dev.bitmaps is None:
                    log.info('No bitmaps found for device: "%s"', dev.node)
                    continue
                log.info("%s:", dev.node)
                log.info("%s", common.json_pp(dev.bitmaps))
        sys.exit(0)

    if action == "cleanup":
        await qemu_client.remove_bitmaps(blockdev)
        log.info("Bitmaps for all devices have been removed")

    if action == "backup":
        if argv.quisce and not argv.agentsocket:
            log.warning(
                "Quisce option set but agent socket is missing, please set via --agent-socket"
            )

        backupdir = argv.target
        if argv.monthly:
            monthdir = datetime.today().strftime("%Y-%m")
            backupdir = f"{backupdir}/{monthdir}"
            if not os.path.exists(backupdir):
                log.info("New monthly directory will be created: %s", backupdir)
                new_monthly = True

        if os.path.isfile(backupdir):
            log.fatal("Backup target must be an directory.")
            sys.exit(1)

        try:
            os.makedirs(backupdir, exist_ok=True)
        except OSError as errmsg:
            log.error("Unable to create target dir: %s", errmsg)
            sys.exit(1)

        for device in blockdev:
            if device.backing_image is True:
                log.error(
                    'Active backing image for disk "%s", please commit any snapshots before starting a new chain.',
                    device.node,
                )
                sys.exit(1)
            if device.has_bitmap is False and argv.level == "inc":
                log.error(
                    "Incremental backup requested but no active bitmap has been found."
                )
                sys.exit(1)

            if argv.level == "auto":
                if (
                    device.has_bitmap
                    and not common.has_full(f"{backupdir}/{device.node}")
                    and new_monthly is False
                ):
                    log.error(
                        "Bitmap exists, but target directory does not contain full backup."
                    )
                    sys.exit(1)

                if device.has_bitmap is False or new_monthly is True:
                    argv.level = "full"
                else:
                    argv.level = "inc"

                log.info("Auto backup mode set to: %s", argv.level)

            if argv.level == "inc":
                if common.check_for_partial(backupdir, device.node):
                    log.error(
                        "Partial backup found in [%s/%s], possible broken backup chain. Exectue new full backup",
                        backupdir,
                        device.node,
                    )
                    sys.exit(1)

        log.info("Backup target directory: %s", backupdir)

        qga = False
        if argv.agentsocket and argv.quisce:
            qga = common.connect_qaagent(argv.agentsocket)
            if qga:
                common.quisce(qga)

        try:
            files = await qemu_client.backup(
                blockdev, argv.level, backupdir, qga, common
            )
        except Exception as errmsg:
            log.fatal("Error executing backup: %s", errmsg)
            if qga is not False:
                common.thaw(qga)
            sys.exit(1)

        await qmp.disconnect()

        if SIGNAL_CATCHED is True:
            log.error("Backup aborted by signal.")
            sys.exit(1)

        log.info("Renaming partial files")
        for saveset in files:
            new_filename = saveset.replace(".partial", "")
            try:
                os.rename(saveset, new_filename)
            except OSError as errmsg:
                log.error("Unable to rename files: %s", errmsg)
                sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
